<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Computation - Computer Science Notes | Josu√© Galindo</title>
    <meta name="description" content="Comprehensive guide to quantum computation: quantum circuits, algorithms, error correction, and NISQ implementations">
    <meta name="author" content="Josu√© Galindo">
    <meta name="keywords" content="quantum computation, quantum algorithms, quantum circuits, Shor algorithm, Grover algorithm, quantum error correction, NISQ">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="../../../assets/css/main.css">
    <link rel="stylesheet" href="../../../assets/css/syntax-highlighting.css">
    <link rel="stylesheet" href="../../../assets/css/utilities.css">
    <link rel="stylesheet" href="../../../config/style-config.css">
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    
    <!-- Favicon -->
    <link rel="icon" href="../../../assets/images/favicon.ico" type="image/x-icon">
</head>

<body>
    <!-- Navigation Header -->
    <header class="site-header">
        <nav class="main-navigation">
            <div class="nav-brand">
                <a href="../../../index.html" class="brand-link">JG</a>
            </div>
            
            <ul class="nav-menu">
                <li><a href="../../about.html" class="nav-link">About</a></li>
                <li><a href="../../projects/index.html" class="nav-link">Projects</a></li>
                <li><a href="../index.html" class="nav-link">Notes</a></li>
                <li><a href="../../../index.html#contact" class="nav-link">Contact</a></li>
            </ul>
            
            <div class="nav-controls">
                <button class="theme-toggle" aria-label="Toggle theme">üåì</button>
                <button class="lang-toggle" aria-label="Language">EN</button>
            </div>
        </nav>
    </header>

    <!-- Note Header Section -->
    <section class="note-header-section">
        <div class="content-container">
            <nav class="breadcrumb">
                <a href="../index.html">Notes</a> > 
                <a href="index.html">Computer Science</a> > 
                <span>Quantum Computation</span>
            </nav>
            
            <div class="note-header">
                <h1>Quantum Computation</h1>
                <div class="note-meta">
                    <span class="note-area cs">Computer Science</span>
                    <span class="note-difficulty advanced">Advanced</span>
                    <span class="note-date">June 19, 2025</span>
                </div>
                
                <div class="note-tags">
                    <span class="tag">Quantum Computing</span>
                    <span class="tag">Quantum Algorithms</span>
                    <span class="tag">Quantum Circuits</span>
                    <span class="tag">Error Correction</span>
                    <span class="tag">NISQ</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main class="note-content">
        <!-- Abstract -->
        <section class="note-abstract">
            <h2>Abstract</h2>
            <p>
                Quantum computation harnesses quantum mechanical phenomena to process information in fundamentally 
                new ways. This comprehensive guide explores quantum algorithms, circuit models, error correction 
                protocols, and practical implementations on Noisy Intermediate-Scale Quantum (NISQ) devices.
            </p>
        </section>

        <!-- Quantum Circuit Model -->
        <section>
            <h2>1. Quantum Circuit Model</h2>
            
            <h3>1.1 Quantum Gates</h3>
            <p>
                Quantum computation operates through unitary transformations applied to quantum states. 
                The fundamental single-qubit gates include:
            </p>
            
            <div class="math-block">
                $$X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}, \quad 
                Y = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}, \quad 
                Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$$
            </div>
            
            <p>The Hadamard gate creates superposition:</p>
            <div class="math-block">
                $$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$
            </div>
            
            <p>Rotation gates provide continuous control:</p>
            <div class="math-block">
                $$R_x(\theta) = \begin{pmatrix} \cos(\theta/2) & -i\sin(\theta/2) \\ -i\sin(\theta/2) & \cos(\theta/2) \end{pmatrix}$$
            </div>

            <h3>1.2 Multi-Qubit Gates</h3>
            <p>The controlled-NOT (CNOT) gate creates entanglement:</p>
            <div class="math-block">
                $$\text{CNOT} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$
            </div>

            <h3>1.3 Circuit Implementation</h3>
            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Qiskit</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.visualization import plot_circuit_layout
import numpy as np

# Create quantum circuit for Bell state preparation
def create_bell_circuit():
    """Create a quantum circuit that prepares a Bell state"""
    qreg = QuantumRegister(2, 'q')
    creg = ClassicalRegister(2, 'c')
    circuit = QuantumCircuit(qreg, creg)
    
    # Prepare Bell state |Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2
    circuit.h(qreg[0])      # Hadamard on first qubit
    circuit.cx(qreg[0], qreg[1])  # CNOT gate
    
    # Measurement
    circuit.measure(qreg, creg)
    
    return circuit

# Quantum Fourier Transform implementation
def qft_circuit(n_qubits):
    """Quantum Fourier Transform on n qubits"""
    circuit = QuantumCircuit(n_qubits)
    
    def qft_rotations(circuit, n):
        if n == 0:
            return circuit
        n -= 1
        circuit.h(n)
        for qubit in range(n):
            circuit.cp(np.pi/2**(n-qubit), qubit, n)
        qft_rotations(circuit, n)
    
    qft_rotations(circuit, n_qubits)
    
    # Swap qubits
    for qubit in range(n_qubits//2):
        circuit.swap(qubit, n_qubits-qubit-1)
    
    return circuit

# Example usage
bell_circuit = create_bell_circuit()
qft_3 = qft_circuit(3)

print("Bell Circuit:")
print(bell_circuit.draw())
print("\nQFT Circuit (3 qubits):")
print(qft_3.draw())</code></pre>
            </div>
        </section>

        <!-- Quantum Algorithms -->
        <section>
            <h2>2. Fundamental Quantum Algorithms</h2>
            
            <h3>2.1 Shor's Algorithm</h3>
            <p>
                Shor's algorithm provides exponential speedup for integer factorization, 
                threatening current cryptographic systems.
            </p>
            
            <p><strong>Algorithm Overview:</strong></p>
            <ol>
                <li>Choose random $a < N$ where $\gcd(a, N) = 1$</li>
                <li>Find period $r$ of function $f(x) = a^x \bmod N$ using quantum period finding</li>
                <li>If $r$ is even and $a^{r/2} \not\equiv -1 \pmod{N}$, compute factors</li>
            </ol>
            
            <p>The quantum period finding uses the Quantum Fourier Transform:</p>
            <div class="math-block">
                $$|\psi\rangle = \frac{1}{\sqrt{Q}} \sum_{j=0}^{Q-1} |j\rangle |a^j \bmod N\rangle$$
            </div>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Period Finding</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">def shor_period_finding(a, N, n_count_qubits):
    """
    Quantum period finding subroutine for Shor's algorithm
    """
    # Create quantum registers
    count_qubits = QuantumRegister(n_count_qubits, 'count')
    aux_qubits = QuantumRegister(n_count_qubits, 'aux')
    c_aux = ClassicalRegister(n_count_qubits, 'c_aux')
    
    circuit = QuantumCircuit(count_qubits, aux_qubits, c_aux)
    
    # Initialize auxiliary register to |1‚ü©
    circuit.x(aux_qubits[0])
    
    # Apply Hadamard to counting qubits
    for i in range(n_count_qubits):
        circuit.h(count_qubits[i])
    
    # Controlled unitary operations U^(2^j)
    for i in range(n_count_qubits):
        power = 2**i
        controlled_modular_exp(circuit, count_qubits[i], 
                              aux_qubits, a, power, N)
    
    # Apply inverse QFT to counting register
    qft_dagger = qft_circuit(n_count_qubits).inverse()
    circuit.append(qft_dagger, count_qubits)
    
    # Measure counting register
    circuit.measure(count_qubits, c_aux)
    
    return circuit

def controlled_modular_exp(circuit, control, target, a, power, N):
    """Controlled modular exponentiation a^power mod N"""
    # Classical preprocessing to compute a^power mod N
    result = pow(a, power, N)
    
    # Implement controlled multiplication by result
    # (This requires a quantum multiplication circuit)
    # Simplified representation:
    if result != 1:
        circuit.cx(control, target[0])  # Placeholder</code></pre>
            </div>

            <h3>2.2 Grover's Algorithm</h3>
            <p>
                Grover's algorithm provides quadratic speedup for unstructured search problems.
                For $N$ items, classical search requires $O(N)$ queries while Grover requires $O(\sqrt{N})$.
            </p>
            
            <p>The algorithm iterates the Grover operator:</p>
            <div class="math-block">
                $$G = (2|s\rangle\langle s| - I)(2|w\rangle\langle w| - I)$$
            </div>
            
            <p>where $|s\rangle = \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}|x\rangle$ and $|w\rangle$ is the marked state.</p>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Grover's Algorithm</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">def grovers_algorithm(n_qubits, marked_item):
    """
    Grover's algorithm for searching a marked item
    """
    N = 2**n_qubits
    n_iterations = int(np.pi * np.sqrt(N) / 4)
    
    circuit = QuantumCircuit(n_qubits, n_qubits)
    
    # Initialize superposition
    for qubit in range(n_qubits):
        circuit.h(qubit)
    
    # Grover iterations
    for _ in range(n_iterations):
        # Oracle: flip phase of marked item
        oracle(circuit, marked_item, n_qubits)
        
        # Diffuser: inversion about average
        diffuser(circuit, n_qubits)
    
    # Measurement
    circuit.measure(range(n_qubits), range(n_qubits))
    
    return circuit

def oracle(circuit, marked_item, n_qubits):
    """Oracle function that flips the phase of marked item"""
    # Convert marked_item to binary and apply X gates
    binary = format(marked_item, f'0{n_qubits}b')
    for i, bit in enumerate(binary):
        if bit == '0':
            circuit.x(i)
    
    # Multi-controlled Z gate
    circuit.h(n_qubits - 1)
    circuit.mcx(list(range(n_qubits - 1)), n_qubits - 1)
    circuit.h(n_qubits - 1)
    
    # Undo X gates
    for i, bit in enumerate(binary):
        if bit == '0':
            circuit.x(i)

def diffuser(circuit, n_qubits):
    """Diffuser operator: 2|s‚ü©‚ü®s| - I"""
    # Apply H gates
    for qubit in range(n_qubits):
        circuit.h(qubit)
    
    # Apply X gates
    for qubit in range(n_qubits):
        circuit.x(qubit)
    
    # Multi-controlled Z
    circuit.h(n_qubits - 1)
    circuit.mcx(list(range(n_qubits - 1)), n_qubits - 1)
    circuit.h(n_qubits - 1)
    
    # Undo X and H gates
    for qubit in range(n_qubits):
        circuit.x(qubit)
    for qubit in range(n_qubits):
        circuit.h(qubit)</code></pre>
            </div>

            <h3>2.3 Variational Quantum Eigensolver (VQE)</h3>
            <p>
                VQE is a hybrid classical-quantum algorithm for finding ground state energies 
                of quantum systems, particularly useful for NISQ devices.
            </p>
            
            <div class="math-block">
                $$E_0 = \min_{\theta} \langle\psi(\theta)|H|\psi(\theta)\rangle$$
            </div>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - VQE Implementation</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">from qiskit.algorithms import VQE
from qiskit.algorithms.optimizers import SPSA
from qiskit.circuit.library import TwoLocal
from qiskit.quantum_info import SparsePauliOp

def vqe_h2_molecule():
    """VQE for H2 molecule ground state"""
    
    # Define H2 Hamiltonian (simplified)
    h2_hamiltonian = SparsePauliOp.from_list([
        ("II", -1.0523732),
        ("IZ", -0.39793742),
        ("ZI", -0.39793742),
        ("ZZ", -0.01128010),
        ("XX", 0.18093119)
    ])
    
    # Create ansatz circuit
    ansatz = TwoLocal(
        num_qubits=2,
        rotation_blocks=['ry', 'rz'],
        entanglement_blocks='cz',
        reps=1
    )
    
    # Set up VQE
    optimizer = SPSA(maxiter=100)
    vqe = VQE(ansatz, optimizer, quantum_instance=None)
    
    return vqe, h2_hamiltonian

# Example execution
def run_vqe_example():
    vqe, hamiltonian = vqe_h2_molecule()
    
    # Note: This would run on a quantum backend
    # result = vqe.compute_minimum_eigenvalue(hamiltonian)
    # print(f"Ground state energy: {result.eigenvalue}")
    
    print("VQE circuit:")
    print(vqe.ansatz.draw())</code></pre>
            </div>
        </section>

        <!-- Quantum Error Correction -->
        <section>
            <h2>3. Quantum Error Correction</h2>
            
            <h3>3.1 Quantum Error Correction Codes</h3>
            <p>
                Quantum error correction protects quantum information from decoherence and noise. 
                The simplest example is the three-qubit bit-flip code.
            </p>
            
            <p><strong>Encoding:</strong></p>
            <div class="math-block">
                $$|0\rangle_L = |000\rangle, \quad |1\rangle_L = |111\rangle$$
            </div>
            
            <p><strong>Error Syndromes:</strong></p>
            <ul>
                <li>$Z_1 Z_2$: detects error on qubit 3</li>
                <li>$Z_2 Z_3$: detects error on qubit 1</li>
                <li>Combination determines error location</li>
            </ul>

            <h3>3.2 Surface Codes</h3>
            <p>
                Surface codes are the leading candidates for fault-tolerant quantum computation 
                due to their high threshold and local connectivity requirements.
            </p>
            
            <div class="math-block">
                $$\text{Threshold} \approx 1\% \text{ physical error rate}$$
            </div>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Error Correction</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">def three_qubit_bit_flip_code():
    """Three-qubit bit-flip error correction code"""
    
    # Encoding circuit
    encoding = QuantumCircuit(5, 2)  # 3 data + 2 ancilla qubits
    
    # Encode logical |0‚ü© or |1‚ü©
    # encoding.x(0)  # Uncomment for logical |1‚ü©
    encoding.cx(0, 1)
    encoding.cx(0, 2)
    
    # Error syndrome measurement
    # Syndrome qubit 1: Z1‚äóZ2
    encoding.cx(0, 3)
    encoding.cx(1, 3)
    
    # Syndrome qubit 2: Z2‚äóZ3  
    encoding.cx(1, 4)
    encoding.cx(2, 4)
    
    # Measure syndrome qubits
    encoding.measure(3, 0)
    encoding.measure(4, 1)
    
    # Error correction (classical post-processing needed)
    # 00: no error
    # 01: error on qubit 2
    # 10: error on qubit 0  
    # 11: error on qubit 1
    
    return encoding

def steane_code_logical_gates():
    """Steane [[7,1,3]] code logical gate implementations"""
    
    # Logical X gate on Steane code
    logical_x = QuantumCircuit(7)
    for i in range(7):
        logical_x.x(i)
    
    # Logical Z gate on Steane code  
    logical_z = QuantumCircuit(7)
    for i in range(4):
        logical_z.z(i)
    
    # Logical Hadamard (more complex, requires transversal implementation)
    logical_h = QuantumCircuit(7)
    for i in range(7):
        logical_h.h(i)
    
    return logical_x, logical_z, logical_h</code></pre>
            </div>
        </section>

        <!-- NISQ and Near-term Applications -->
        <section>
            <h2>4. NISQ Era and Near-term Applications</h2>
            
            <h3>4.1 Noisy Intermediate-Scale Quantum (NISQ) Devices</h3>
            <p>
                Current quantum computers operate in the NISQ regime, characterized by:
            </p>
            <ul>
                <li>50-1000 qubits</li>
                <li>Limited gate fidelity (~99%)</li>
                <li>Short coherence times</li>
                <li>No full error correction</li>
            </ul>

            <h3>4.2 Quantum Error Mitigation</h3>
            <p>
                Since full error correction is not yet feasible, error mitigation techniques 
                are crucial for NISQ applications.
            </p>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Error Mitigation</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">from qiskit.ignis.mitigation.measurement import complete_meas_cal
from qiskit.ignis.mitigation.measurement import CompleteMeasFitter

def zero_noise_extrapolation(circuit, backend, noise_factors=[1, 2, 3]):
    """Zero Noise Extrapolation for error mitigation"""
    
    results = []
    
    for factor in noise_factors:
        # Scale noise by repeating gates
        scaled_circuit = scale_noise(circuit, factor)
        
        # Execute circuit
        job = backend.run(scaled_circuit, shots=1024)
        result = job.result()
        counts = result.get_counts()
        
        # Extract expectation value
        expectation = calculate_expectation(counts)
        results.append((factor, expectation))
    
    # Extrapolate to zero noise
    zero_noise_value = extrapolate_to_zero(results)
    return zero_noise_value

def scale_noise(circuit, factor):
    """Scale circuit noise by factor"""
    scaled = QuantumCircuit(circuit.num_qubits, circuit.num_clbits)
    
    for instruction, qargs, cargs in circuit.data:
        # Add original gate
        scaled.append(instruction, qargs, cargs)
        
        # Add (factor-1) pairs of gate and its inverse
        if instruction.name in ['cx', 'ry', 'rz']:
            for _ in range(factor - 1):
                scaled.append(instruction, qargs, cargs)
                scaled.append(instruction.inverse(), qargs, cargs)
    
    return scaled

def readout_error_mitigation(backend, qubits):
    """Measurement error mitigation using calibration"""
    
    # Generate calibration circuits
    cal_circuits, state_labels = complete_meas_cal(
        qubits=qubits, 
        circlabel='measurement_calibration'
    )
    
    # Execute calibration
    cal_job = backend.run(cal_circuits, shots=1024)
    cal_results = cal_job.result()
    
    # Create measurement filter
    meas_fitter = CompleteMeasFitter(cal_results, state_labels)
    meas_filter = meas_fitter.filter
    
    return meas_filter

# Quantum Approximate Optimization Algorithm (QAOA)
def qaoa_maxcut(graph, p_layers=1):
    """QAOA for Max-Cut problem"""
    
    n_qubits = len(graph.nodes())
    
    # Create parameterized circuit
    theta = [0.5] * (2 * p_layers)  # Initial parameters
    
    circuit = QuantumCircuit(n_qubits)
    
    # Initial state: equal superposition
    for i in range(n_qubits):
        circuit.h(i)
    
    # QAOA layers
    for layer in range(p_layers):
        # Problem Hamiltonian (MaxCut)
        gamma = theta[2 * layer]
        for edge in graph.edges():
            circuit.rzz(gamma, edge[0], edge[1])
        
        # Mixer Hamiltonian
        beta = theta[2 * layer + 1]
        for i in range(n_qubits):
            circuit.rx(beta, i)
    
    # Measurement
    circuit.measure_all()
    
    return circuit</code></pre>
            </div>

            <h3>4.3 Quantum Machine Learning</h3>
            <p>
                Quantum machine learning explores potential quantum advantages in learning tasks.
            </p>

            <div class="code-block-container">
                <div class="code-block-header">
                    <span class="language-label">Python - Quantum Classifier</span>
                    <button class="copy-code-btn" onclick="copyCode(this)">üìã</button>
                </div>
                <pre><code class="language-python">def quantum_neural_network(n_qubits, n_layers):
    """Variational quantum neural network"""
    
    circuit = QuantumCircuit(n_qubits)
    
    # Data encoding layer
    for i in range(n_qubits):
        circuit.ry(0, i)  # Parameter for data encoding
    
    # Variational layers
    for layer in range(n_layers):
        # Entangling layer
        for i in range(n_qubits - 1):
            circuit.cx(i, i + 1)
        
        # Rotation layer
        for i in range(n_qubits):
            circuit.ry(0, i)  # Trainable parameter
            circuit.rz(0, i)  # Trainable parameter
    
    return circuit

def quantum_kernel_method(x1, x2):
    """Quantum kernel for classification"""
    
    n_qubits = len(x1)
    circuit = QuantumCircuit(n_qubits)
    
    # Encode first data point
    for i, val in enumerate(x1):
        circuit.ry(val, i)
    
    # Encode second data point (adjoint)
    for i, val in enumerate(x2):
        circuit.ry(-val, i)
    
    # Measure overlap
    circuit.measure_all()
    
    return circuit</code></pre>
            </div>
        </section>

        <!-- Quantum Hardware -->
        <section>
            <h2>5. Quantum Hardware Implementations</h2>
            
            <h3>5.1 Superconducting Qubits</h3>
            <p>
                Superconducting qubits use Josephson junctions to create artificial atoms 
                with controllable energy levels.
            </p>
            
            <p><strong>Transmon Qubit Hamiltonian:</strong></p>
            <div class="math-block">
                $$H = 4E_C(\hat{n} - n_g)^2 - E_J \cos(\hat{\phi})$$
            </div>
            
            <p>where $E_C$ is the charging energy and $E_J$ is the Josephson energy.</p>

            <h3>5.2 Trapped Ion Systems</h3>
            <p>
                Trapped ions use individual atoms as qubits, offering high fidelity 
                and all-to-all connectivity.
            </p>
            
            <p><strong>Motional Coupling Hamiltonian:</strong></p>
            <div class="math-block">
                $$H_{int} = \hbar \Omega \sum_{i,j} \eta_{ij} \sigma_i^x (a_j e^{-i\omega_j t} + a_j^\dagger e^{i\omega_j t})$$
            </div>

            <h3>5.3 Photonic Quantum Computing</h3>
            <p>
                Photonic systems use photons as qubits, enabling room-temperature operation 
                and natural networking capabilities.
            </p>
        </section>

        <!-- Future Directions -->
        <section>
            <h2>6. Future Directions and Challenges</h2>
            
            <h3>6.1 Fault-Tolerant Quantum Computing</h3>
            <p>
                Achieving fault-tolerant quantum computation requires:
            </p>
            <ul>
                <li>Error rates below threshold (~10‚Åª¬≥)</li>
                <li>Millions of physical qubits</li>
                <li>Fast, high-fidelity quantum error correction</li>
                <li>Efficient compilation of logical operations</li>
            </ul>

            <h3>6.2 Quantum Advantage Applications</h3>
            <p>
                Promising areas for quantum advantage include:
            </p>
            <ul>
                <li><strong>Cryptography:</strong> Breaking RSA, post-quantum cryptography</li>
                <li><strong>Chemistry:</strong> Molecular simulation, drug discovery</li>
                <li><strong>Optimization:</strong> Portfolio optimization, logistics</li>
                <li><strong>Machine Learning:</strong> Quantum-enhanced learning algorithms</li>
            </ul>

            <h3>6.3 Quantum Networking</h3>
            <p>
                Quantum internet will enable:
            </p>
            <ul>
                <li>Distributed quantum computing</li>
                <li>Quantum-secured communication</li>
                <li>Remote quantum sensing</li>
                <li>Clock synchronization</li>
            </ul>
        </section>

        <!-- Conclusion -->
        <section>
            <h2>Conclusion</h2>
            <p>
                Quantum computation represents a paradigm shift in information processing, 
                offering exponential speedups for specific problems. While current NISQ devices 
                have limitations, they provide valuable platforms for algorithm development 
                and error mitigation research. The path to fault-tolerant quantum computing 
                requires advances in hardware, software, and error correction protocols.
            </p>
            
            <p>
                The field continues to evolve rapidly, with new algorithms, hardware platforms, 
                and applications emerging regularly. Understanding both the theoretical foundations 
                and practical implementations is crucial for leveraging quantum computational 
                advantages in real-world applications.
            </p>
        </section>
    </main>

    <!-- Navigation -->
    <section class="note-navigation">
        <div class="nav-links">
            <a href="quantum-information.html" class="nav-link prev">‚Üê Quantum Information</a>
            <a href="index.html" class="nav-link up">‚Üë Computer Science</a>
            <a href="#" class="nav-link next">Generative AI ‚Üí</a>
        </div>
    </section>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>Related Topics</h4>
                <ul class="footer-nav">
                    <li><a href="quantum-information.html">Quantum Information</a></li>
                    <li><a href="../physics/quantum-mechanics.html">Quantum Mechanics</a></li>
                    <li><a href="../mathematics/linear-algebra.html">Linear Algebra</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4>External Resources</h4>
                <ul class="footer-nav">
                    <li><a href="https://qiskit.org/" target="_blank">Qiskit Documentation</a></li>
                    <li><a href="https://quantum-computing.ibm.com/" target="_blank">IBM Quantum</a></li>
                    <li><a href="https://arxiv.org/list/quant-ph/recent" target="_blank">arXiv Quantum Physics</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <p class="footer-note">
                    Quantum computation notes ‚Ä¢ Updated June 19, 2025
                </p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="../../../config/latex-config.js"></script>
    <script src="../../../assets/js/theme-switcher.js"></script>
    <script src="../../../assets/js/latex-renderer.js"></script>
    <script src="../../../assets/js/enhanced-syntax-highlighter.js"></script>
    <script src="../../../assets/js/main.js"></script>
    
    <script>
        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.parentElement.nextElementSibling.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úÖ';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }
    </script>
</body>
</html>